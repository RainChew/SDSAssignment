# Training set 282.21 2649.997 2165.336 8.824996 284.2446 0.4275203 0.003777608
# Box.test(resid(fit),lag=24,type = c("Ljung-Box"))
# checkresiduals(sarima_model)
# Box-Ljung test
#
# data:  resid(fit)
# X-squared = 23.102, df = 24, p-value = 0.5138
coeftest(fit_sarima)
acf(residuals(fit_sarima))
pacf(residuals(fit_sarima))
checkresiduals(fit_sarima)
sarima_forecasts <- forecast(fit_sarima, h = length(Y_test))
accuracy_metrics <- accuracy(sarima_forecasts, Y_test)
print(accuracy_metrics)
# Plot the SARIMA forecasts and actual data
plot(sarima_forecasts, main = "SARIMA Forecast vs. Actual")
lines(Y_test, col = "red")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
lines(Y_test, col = "red")
# Plot the SARIMA forecasts and actual data
plot(sarima_forecasts, main = "SARIMA Forecast vs. Actual")
lines(Y_test, col = "red")
# Ljung-Box test
#
# data:  Residuals from ARIMA(1,1,3)(0,1,1)[12]
# Q* = 33.145, df = 12, p-value = 0.0009188
#
# Model df: 5.   Total lags used: 17fit <- auto.arima(diff_Y)
fit_sarima <-auto.arima(Y_train,ic = "aic",trace = TRUE)
#
# Training set error measures:
#   ME     RMSE      MAE      MPE     MAPE      MASE        ACF1
# Training set 282.21 2649.997 2165.336 8.824996 284.2446 0.4275203 0.003777608
# Box.test(resid(fit),lag=24,type = c("Ljung-Box"))
# checkresiduals(sarima_model)
# Box-Ljung test
#
# data:  resid(fit)
# X-squared = 23.102, df = 24, p-value = 0.5138
coeftest(fit_sarima)
acf(residuals(fit_sarima))
pacf(residuals(fit_sarima))
checkresiduals(fit_sarima)
sarima_forecasts <- forecast(fit_sarima, h = length(Y_test))
accuracy_metrics <- accuracy(sarima_forecasts, Y_test)
print(accuracy_metrics)
# Plot the SARIMA forecasts and actual data
plot(sarima_forecasts, main = "SARIMA Forecast vs. Actual")
lines(Y_test, col = "red")
#
# Training set error measures:
#   ME     RMSE      MAE      MPE     MAPE      MASE        ACF1
# Training set 282.21 2649.997 2165.336 8.824996 284.2446 0.4275203 0.003777608
# Box.test(resid(fit),lag=24,type = c("Ljung-Box"))
# checkresiduals(sarima_model)
# Box-Ljung test
#
# data:  resid(fit)
# X-squared = 23.102, df = 24, p-value = 0.5138
coeftest(fit_sarima)
acf(residuals(fit_sarima))
pacf(residuals(fit_sarima))
checkresiduals(fit_sarima)
sarima_forecasts <- forecast(fit_sarima, h = length(Y_test))
accuracy_metrics <- accuracy(sarima_forecasts, Y_test)
print(accuracy_metrics)
# Plot the SARIMA forecasts and actual data
plot(sarima_forecasts, main = "SARIMA Forecast vs. Actual")
lines(Y_test, col = "red")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
# Ljung-Box test
#
# data:  Residuals from ARIMA(1,1,3)(0,1,1)[12]
# Q* = 33.145, df = 12, p-value = 0.0009188
#
# Model df: 5.   Total lags used: 17fit <- auto.arima(diff_Y)
fit_sarima <-auto.arima(Y,ic = "aic",trace = TRUE)
#
# Training set error measures:
#   ME     RMSE      MAE      MPE     MAPE      MASE        ACF1
# Training set 282.21 2649.997 2165.336 8.824996 284.2446 0.4275203 0.003777608
# Box.test(resid(fit),lag=24,type = c("Ljung-Box"))
# checkresiduals(sarima_model)
# Box-Ljung test
#
# data:  resid(fit)
# X-squared = 23.102, df = 24, p-value = 0.5138
coeftest(fit_sarima)
acf(residuals(fit_sarima))
pacf(residuals(fit_sarima))
checkresiduals(fit_sarima)
sarima_forecasts <- forecast(fit_sarima, h = length(Y_test))
accuracy_metrics <- accuracy(sarima_forecasts, Y_test)
print(accuracy_metrics)
# Plot the SARIMA forecasts and actual data
plot(sarima_forecasts, main = "SARIMA Forecast vs. Actual")
lines(Y_test, col = "red")
#
# Training set error measures:
#   ME     RMSE      MAE      MPE     MAPE      MASE        ACF1
# Training set 282.21 2649.997 2165.336 8.824996 284.2446 0.4275203 0.003777608
# Box.test(resid(fit),lag=24,type = c("Ljung-Box"))
# checkresiduals(sarima_model)
# Box-Ljung test
#
# data:  resid(fit)
# X-squared = 23.102, df = 24, p-value = 0.5138
coeftest(fit_sarima)
acf(residuals(fit_sarima))
pacf(residuals(fit_sarima))
checkresiduals(fit_sarima)
sarima_forecasts <- forecast(fit_sarima, h = length(Y_test))
accuracy_metrics <- accuracy(sarima_forecasts, Y_test)
# Plot the SARIMA forecasts and actual data
plot(sarima_forecasts, main = "SARIMA Forecast vs. Actual")
lines(Y_test, col = "red")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
fit_sarima <- arima(Y_train, order = c(2, 1, 1), seasonal = list(order = c(2, 0, 0), period = 12))
summary(fit_sarima)
summary(fit_sarima)
checkresiduals(fit_sarima)
sarima_forecasts <- forecast(fit_sarima, h = length(Y_test))
accuracy_metrics <- accuracy(sarima_forecasts, Y_test)
print(accuracy_metrics)
# Plot the SARIMA forecasts and actual data
plot(sarima_forecasts, main = "SARIMA Forecast vs. Actual")
lines(Y_test, col = "red")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
# ETS Model
# ETS
fit <- ets(Y_train)
fit
summary(fit)
autoplot(fit)
# Make forecasts
# forecast_values <- forecast((fit), h = 12)  # Forecast for the next 12 periods
checkresiduals(fit)
forecast<-forecast(fit)
forecast
plot(forecast(fit))
# Print the forecasted values
print(forecast_values)
library(stats)
fit1 <- ets(Y_train, model="ANA", alpha=1e-04)
summary(fit1)
accuracy(forecast(fit1), Y_test)
checkresiduals(fit1)
plot(forecast(fit1))
# simple exponential smoothing
# Estimating the level of time series using simple exponential
es1 <- HoltWinters(diff_Y, alpha=1e-04, beta=FALSE, gamma=FALSE)
checkresiduals(fit1)
plot(forecast(fit1))
plot(fit1, main = "ETS Forecast vs. Actual")
checkresiduals(fit1)
ets_forecast = forecast(fit1)
plot(ets_forecast)
plot(ets_forecasts, main = "ETS Forecast vs. Actual")
lines(Y_test, col = "red")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
# Make forecasts
# forecast_values <- forecast((fit), h = 12)  # Forecast for the next 12 periods
checkresiduals(fit)
forecast<-forecast(fit)
forecast
plot(forecast(fit))
# Print the forecasted values
print(forecast_values)
library(stats)
fit1 <- ets(Y_train, model="ANA", alpha=1e-04)
summary(fit1)
accuracy(forecast(fit1), Y_test)
checkresiduals(fit1)
ets_forecast = forecast(fit1)
plot(ets_forecast)
plot(ets_forecasts, main = "ETS Forecast vs. Actual")
lines(Y_test, col = "red")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
accuracy(forecast(fit1), Y_test)
fit2 <- ets(Y_test, model = fit1)
Box.test(fit2$residuals, type="Ljung", lag=24)
accuracy(fit2)
ets_forecast2 = forecast(fit2)
plot(ets_forecasts2, main = "ETS Forecast vs. Actual")
lines(Y_test, col = "red")
ets_forecast2 = forecast(fit2)
plot(ets_forecasts2, main = "ETS Forecast vs. Actual")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
# ETS Model
# ETS
fit <- ets(Y_train)
fit
summary(fit)
autoplot(fit)
# Make forecasts
# forecast_values <- forecast((fit), h = 12)  # Forecast for the next 12 periods
checkresiduals(fit)
forecast<-forecast(fit)
forecast
# ETS Model
# ETS
fit <- ets(Y_train)
fit
# Make forecasts
# forecast_values <- forecast((fit), h = 12)  # Forecast for the next 12 periods
checkresiduals(fit)
forecast<-forecast(fit)
forecast
plot(forecast(fit))
# Print the forecasted values
print(forecast_values)
library(stats)
fit1 <- ets(Y_train, model="ANA", alpha=0.3151,gamma=1e-04)
summary(fit1)
accuracy(forecast(fit1), Y_test)
checkresiduals(fit1)
ets_forecast = forecast(fit1)
plot(ets_forecast)
plot(ets_forecasts, main = "ETS Forecast vs. Actual")
lines(Y_test, col = "red")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
plot(forecast(fit),main = "ETS Forecast vs. Actual")
lines(Y_test, col = "red")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
# Print the forecasted values
print(forecast_values)
library(stats)
fit1 <- ets(Y_train, model="ANA", alpha=0.3151,gamma=1e-04)
summary(fit1)
accuracy(forecast(fit1), Y_test)
checkresiduals(fit1)
ets_forecast = forecast(fit1)
plot(ets_forecast)
plot(ets_forecasts, main = "ETS Forecast vs. Actual")
lines(Y_test, col = "red")
legend("topright", legend = c("Forecast", "Actual"), col = c("blue", "red"), lty = 1)
# simple exponential smoothing
# Estimating the level of time series using simple exponential
es1 <- HoltWinters(diff_Y, alpha=1e-04, beta=FALSE, gamma=FALSE)
es1
plot(es1)
# Call SSE and calculate the MSE
es1$SSE
MSE <- es1$"SSE"/(length(diff_Y))
MSE
# Check randomness of the residuals
checkresiduals(es1)
# Computes predictions and prediction intervals
forecast <- predict(es1, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(es1,forecast)
# Hot Winter Addictive Models
# Estimating the level of time series using simple exponential
decompose_candy = decompose(y)
# Hot Winter Addictive Models
# Estimating the level of time series using simple exponential
decompose_candy = decompose(Y)
plot(Y)
# Hot Winter Addictive Models
# Estimating the level of time series using simple exponential
decompose_candy = decompose(Y)
plot(decompose)
# Hot Winter Addictive Models
# Estimating the level of time series using simple exponential
decompose = decompose(Y)
plot(decompose)
#Holt-Winter Additive Method
library(forecast)
HW1 <- HoltWinters(Y ,seasonal = "additive")
HW1
#Visually evaluate
plot(Y, ylab="Trade Balance(RM)", xlim=c(2010,2019))
#Visually evaluate
plot(Y, ylab="Trade Balance(RM)", xlim=c(2010,2020))
lines(HW1$fitted[,1], lty=2, col="red")
HW1 <- HoltWinters(Y ,seasonal = "additive",alpha = 0.2,beta = 0.01,gamma=0.21)
HW1
#Visually evaluate
plot(Y, ylab="Trade Balance(RM)", xlim=c(2010,2020))
lines(HW1$fitted[,1], lty=2, col="red")
hw <- HoltWinters(Y ,seasonal = "additive",alpha = 0.2,beta = 0.01,gamma=0.21)
hw
plot(hw)
MSE <- hw$"SSE"/(NROW(Bike)-3)
MSE <- hw$"SSE"/(NROW(Y)-3)
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
MSE <- hw$"SSE"/(NROW(Y_test)-3)
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
MSE <- hw$"SSE"/(NROW(Y_test)-3)
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
# Call SSE and calculate the MSE
es1$SSE
MSE <- es1$"SSE"/(length(diff_Y))
MSE
# Check randomness of the residuals
checkresiduals(es1)
hw <- HoltWinters(Y_test ,seasonal = "additive",alpha = 0.2,beta = 0.01,gamma=0.21)
hw
plot(hw)
MSE <- hw$"SSE"/(NROW(Y_test)-3)
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
hw <- HoltWinters(Y_train ,seasonal = "additive",alpha = 0.2,beta = 0.01,gamma=0.21)
hw
plot(hw)
MSE <- hw$"SSE"/(NROW(Y_test)-3)
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
# Forecasting
forecast <- forecast(hw, h = 10, prediction.interval = TRUE, level = 0.95)
# Plotting
library(ggplot2)
autoplot(hw, series = "Fitted") +
autolayer(ts_data, series = "Actual") +
autolayer(forecast, series = "Forecast") +
labs(title = "Holt-Winters Additive Forecast") +
theme_minimal()
autoplot(hw, series = "Fitted") +
autolayer(Y, series = "Actual") +
autolayer(forecast, series = "Forecast") +
labs(title = "Holt-Winters Additive Forecast") +
theme_minimal()
# Plotting
library(ggplot2)
autoplot(hw, series = "Fitted") +
autolayer(Y, series = "Actual") +
autolayer(forecast, series = "Forecast") +
labs(title = "Holt-Winters Additive Forecast") +
theme_minimal()
# Plotting
library(ggplot2)
autoplot(hw, series = "Fitted") +
autolayer(Y, series = "Actual") +
autolayer(forecast, series = "Forecast") +
labs(title = "Holt-Winters Additive Forecast") +
theme_minimal()
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
MSE
MSE <- hw$"SSE"/(NROW(Y_test)-3)
MSE
hw <- HoltWinters(Y_train ,seasonal = "additive",alpha = 0.2,beta = 0.01,gamma=0.21)
hw
hw <- HoltWinters(Y_train ,seasonal = "additive")
hw
plot(hw)
MSE <- hw$"SSE"/(NROW(Y_test)-3)
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
MSE <- hw$"SSE"/(length(Y))
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
MSE <- hw$"SSE"/(length(Y_test))
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
#Holt-Winter Multiplicative Method
library(forecast)
hw <- HoltWinters(Y_train ,seasonal = "multiplicative")
hw
plot(hw)
MSE <- hw$"SSE"/(length(Y_test))
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
plot(Y_test,forecast)
forecast <- predict(object=hw, n.ahead=10, prediction.interval=Y_test,
level=.95)
?predict
forecast <- predict(object=hw, n.ahead=24, prediction.interval=T,
level=.95)
?predict
forecast
plot(hw,forecast)
hw <- HoltWinters(Y_train ,seasonal = "additive")
hw
plot(hw)
MSE <- hw$"SSE"/(length(Y_test))
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=24, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
#Holt-Winter Multiplicative Method
library(forecast)
hw <- HoltWinters(Y_train ,seasonal = "multiplicative")
hw
plot(hw)
MSE <- hw$"SSE"/(length(Y_test))
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=24, prediction.interval=T,
level=.95)
?predict
forecast
plot(hw,forecast)
# Call SSE and calculate the MSE
es1$SSE
MSE <- es1$"SSE"/(length(diff_Y))
MSE
?predict
checkresiduals(hw)
?predict
forecast
plot(hw,forecast)
# Call SSE and calculate the MSE
es1$SSE
MSE <- es1$"SSE"/(length(diff_Y))
MSE
# Check randomness of the residuals
checkresiduals(es1)
# Hot Winter Addictive Models
# Estimating the level of time series using simple exponential
decompose = decompose(Y)
plot(decompose)
#Holt-Winter Additive Method
library(forecast)
hw <- HoltWinters(Y_train ,seasonal = "additive")
hw
plot(hw)
MSE <- hw$"SSE"/(length(Y_test))
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=24, prediction.interval=T,
level=.95)
forecast
plot(hw,forecast)
#Holt-Winter Multiplicative Method
library(forecast)
hw <- HoltWinters(Y_train ,seasonal = "multiplicative")
hw
plot(hw)
MSE <- hw$"SSE"/(length(Y_test))
MSE
checkresiduals(hw)
hw <- HoltWinters(Y_train ,seasonal = "multiplicative")
hw
plot(hw)
MSE <- hw$"SSE"/(length(Y_test))
MSE
checkresiduals(hw)
forecast <- predict(object=hw, n.ahead=24, prediction.interval=T,
level=.95)
?predict
MSE <- hw$"SSE"/(NROW(Y)-3)
MSE
MSE <- hw$"SSE"/((NROW(Y)-3))
MSE
# Hot Winter Addictive Models
# Estimating the level of time series using simple exponential
decompose = decompose(Y)
plot(decompose)
#Holt-Winter Additive Method
library(forecast)
hw <- HoltWinters(Y_train ,seasonal = "additive")
hw
plot(hw)
MSE <- hw$"SSE"/((NROW(Y)-3))
MSE
hw2 <- HoltWinters(Y_train ,seasonal = "multiplicative")
hw2
plot(hw2)
MSE <- hw2$"SSE"/(NROW(Y)-3)
MSE
checkresiduals(hw2)
forecast <- predict(object=hw2, n.ahead=24, prediction.interval=T,
level=.95)
?predict
forecast
plot(hw,forecast)
plot(hw2,forecast)
